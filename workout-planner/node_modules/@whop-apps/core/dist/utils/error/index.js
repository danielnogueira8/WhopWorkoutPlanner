"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "StandardError", {
    enumerable: true,
    get: function() {
        return StandardError;
    }
});
const _result = /*#__PURE__*/ _interop_require_wildcard(require("../result"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class StandardError extends Error {
    code;
    options;
    constructor(code, message, options){
        super(message, options?.cause ? {
            cause: options.cause
        } : undefined);
        this.code = code;
        this.options = options;
        const { markSpanAsErrored = false, recordException = false } = options ?? {};
        const span = options?.span ?? globalThis._StandardErrorConfiguration?.tracer?.getActiveSpan?.();
        if (span) {
            if (markSpanAsErrored) span.setStatus({
                code: 2,
                message: this.message
            });
            if (recordException) span.recordException(this);
            else span.addEvent("whop.standard_error", this.toJSON());
            span.setAttribute("whop.standard_error.message", this.message);
            span.setAttribute("whop.standard_error.code", this.code);
        }
    }
    static from(error, opts) {
        const err = opts?.fromAny ? StandardError.fromAnything(error, opts) : StandardError.fromStandardError(error);
        if (opts?.throw && err === null) throw error;
        return err;
    }
    static fromAnything(error, opts) {
        if (error instanceof StandardError) return error;
        if (error instanceof Error) return new StandardError(500, error.message, {
            cause: error.cause
        });
        if (typeof error === "string") return new StandardError(500, error);
        const getErrorMessage = ()=>{
            const DEFAULT_MESSAGE = "An unexpected error occurred, please try again.";
            if (typeof opts?.message === "function") {
                return opts.message(error) ?? DEFAULT_MESSAGE;
            }
            return opts?.message ?? DEFAULT_MESSAGE;
        };
        if (error === null || error === undefined) return new StandardError(500, getErrorMessage());
        const message = typeof error === "object" && "message" in error && typeof error.message === "string" ? error.message : getErrorMessage();
        const code = typeof error === "object" && "code" in error && typeof error.code === "number" ? error.code : 500;
        return new StandardError(code, message);
    }
    static fromStandardError(error) {
        if (error instanceof StandardError) return error;
        if (error === null) return null;
        const message = typeof error === "object" && "message" in error && typeof error.message === "string" ? error.message : null;
        const code = typeof error === "object" && "code" in error && typeof error.code === "number" ? error.code : null;
        if (!(message && code)) return null;
        return new StandardError(code, message);
    }
    toResponse({ headers = new Headers() } = {}) {
        const body = JSON.stringify(this.toJSON());
        headers.set("Content-Type", "application/json");
        return new Response(body, {
            status: this.code,
            headers
        });
    }
    toJSON() {
        return {
            message: this.message,
            code: this.code
        };
    }
    toStandardResult() {
        return (0, _result.Err)(this);
    }
    toStandardResultData() {
        return (0, _result.Err)(this.toJSON()).toJSON();
    }
    static httpHandler(fn, opts) {
        const headers = opts?.headers ?? new Headers();
        headers.set("Content-Type", "application/json");
        const wrapped = StandardError.safe(fn, {
            json: true,
            fromAny: opts?.fromAny
        });
        return (...args)=>{
            const value = wrapped(...args);
            if (value instanceof Promise) {
                return value.then((result)=>{
                    const status = result.error?.code ?? opts?.successCode ?? 200;
                    return new Response(JSON.stringify(result), {
                        status,
                        headers
                    });
                });
            }
            const status = value.error?.code ?? opts?.successCode ?? 200;
            return new Response(JSON.stringify(value), {
                status,
                headers
            });
        };
    }
    static safe(fn, opts) {
        return (...args)=>{
            try {
                const potentialPromise = fn(...args);
                if (potentialPromise instanceof Promise) {
                    return potentialPromise.then((data)=>{
                        const d = (0, _result.Ok)(data);
                        return opts?.json ? d.toJSON() : d;
                    }).catch((error)=>{
                        const e = StandardError.from(error, opts);
                        if (!e) throw error;
                        return opts?.json ? e.toStandardResultData() : e.toStandardResult();
                    });
                }
                const d = (0, _result.Ok)(potentialPromise);
                return opts?.json ? d.toJSON() : d;
            } catch (error) {
                const e = StandardError.from(error, opts);
                if (!e) throw error;
                return opts?.json ? e.toStandardResultData() : e.toStandardResult();
            }
        };
    }
    static parse(opts) {
        return (error)=>{
            if (error instanceof TypeError && error.message === "Failed to fetch") {
                return (0, _result.Err)(new StandardError(1001, "Your network seems to be disconnected, please connect to the internet and try again."));
            }
            const msg = typeof opts?.message === "function" ? opts.message(error) : opts?.message ?? "Failed to complete request, please try again later.";
            return (0, _result.Err)(new StandardError(500, msg, {
                recordException: true,
                markSpanAsErrored: true
            }));
        };
    }
    static parseResult() {
        return (data)=>{
            const result = _result.default.from(data);
            return result.mapErr((data)=>StandardError.fromAnything(data));
        };
    }
}
globalThis._ConfigureStandardError = function ConfigureStandardError(options) {
    globalThis._StandardErrorConfiguration = options;
};
