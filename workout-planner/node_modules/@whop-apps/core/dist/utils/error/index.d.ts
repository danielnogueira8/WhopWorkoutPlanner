import Result, { type ErrorResult, type ErrorResultData, type OkResult, type ResultData } from "../result";
export interface StandardErrorOptions extends ErrorOptions {
    markSpanAsErrored?: boolean;
    recordException?: boolean;
    span?: Span;
}
export declare class StandardError extends Error implements StandardErrorData {
    code: number;
    options?: StandardErrorOptions;
    constructor(code: number, message: string, options?: StandardErrorOptions);
    static from<FromAny extends boolean = false>(error: unknown, opts?: ({
        fromAny?: FromAny;
        throw?: undefined;
    } | {
        throw?: FromAny;
        fromAny?: undefined;
    }) & {
        message?: string | ((err: unknown) => string);
    }): FromAny extends true ? StandardError : StandardError | null;
    private static fromAnything;
    private static fromStandardError;
    toResponse({ headers }?: {
        headers?: Headers;
    }): Response;
    toJSON(): {
        message: string;
        code: number;
    };
    toStandardResult(): ErrorStandardResult;
    toStandardResultData(): ErrorStandardResultData;
    static httpHandler<Args extends any[], Ret>(fn: (...args: Args) => Promise<Ret>, opts?: {
        fromAny?: boolean;
        headers?: Headers;
        successCode?: number;
    }): (...args: Args) => Promise<Response>;
    static httpHandler<Args extends any[], Ret>(fn: (...args: Args) => Ret, opts?: {
        fromAny?: boolean;
        headers?: Headers;
        successCode?: number;
    }): (...args: Args) => Response;
    static safe<Args extends any[], Ret, IsJson extends boolean = false>(fn: (...args: Args) => Promise<Ret>, opts?: {
        json?: IsJson;
        fromAny?: boolean;
        message?: string | ((err: unknown) => string);
    }): (...args: Args) => Promise<IsJson extends true ? StandardResultData<Ret> : StandardResult<Ret>>;
    static safe<Args extends any[], Ret, IsJson extends boolean = false>(fn: (...args: Args) => Ret, opts?: {
        json?: IsJson;
        fromAny?: boolean;
        message?: string | ((err: unknown) => string);
    }): (...args: Args) => IsJson extends true ? StandardResultData<Ret> : StandardResult<Ret>;
    static parse(opts?: {
        message: string | ((error: unknown) => string);
    }): (error: unknown) => ErrorResult<StandardError, object>;
    static parseResult<T>(): (data: StandardResultData<T>) => ErrorResult<StandardError, object> | OkResult<T, object>;
}
export interface StandardErrorData {
    message: string;
    code: number;
}
export type StandardResult<T> = Result<T, StandardError>;
export type StandardResultData<T> = ResultData<T, StandardErrorData>;
export type ErrorStandardResult = ErrorResult<StandardError>;
export type ErrorStandardResultData = ErrorResultData<StandardErrorData>;
export type StandardErrorConfigOptions = {
    tracer?: {
        getActiveSpan?(): Span | undefined;
    };
};
declare global {
    function _ConfigureStandardError(options?: StandardErrorConfigOptions): void;
    let _StandardErrorConfiguration: StandardErrorConfigOptions | undefined;
}
type Exception = {
    code: string | number;
    message: string;
    name?: string;
    stack?: string;
};
interface Span {
    setStatus(status: {
        code: 2;
        message?: string;
    }): this;
    recordException(exception: Exception): void;
    setAttribute(key: string, value: string | number): this;
    addEvent(name: string, attributes?: Record<string, string | number>): this;
}
export {};
//# sourceMappingURL=index.d.ts.map