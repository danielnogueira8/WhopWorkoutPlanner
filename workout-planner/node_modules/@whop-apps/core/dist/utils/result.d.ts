export type OkResultData<Data, Common extends object = object> = {
    readonly status: "ok";
    readonly data: Data;
    readonly error: undefined;
} & Omit<Common, ResultKeys>;
export type ErrorResultData<Err, Common extends object = object> = {
    readonly status: "error";
    readonly data: undefined;
    readonly error: Err;
} & Omit<Common, ResultKeys>;
export type ResultData<Data, Err, Constant extends object = object> = OkResultData<Data, Constant> | ErrorResultData<Err, Constant>;
export type OkResult<Data, Common extends object = object> = OkResultData<Data, Common> & OkResultMethods<Data, Common>;
export type ErrorResult<Err, Common extends object = object> = ErrorResultData<Err, Common> & ErrorResultMethods<Err, Common>;
export type Result<Data, Err, Constant extends object = object> = OkResult<Data, Constant> | ErrorResult<Err, Constant>;
type ResultKeys = "isOk" | "data" | "status" | "error" | "isErr" | "unwrap" | "or" | "mapOk" | "mapErr" | "map" | "and" | "andPromise" | "orElse" | "toJSON" | "toResponse";
type ErrorResultMethods<Err, Common extends object> = {
    get isOk(): false;
    get isErr(): true;
    unwrap(): never;
    or<U>(defaultValue: U): U;
    orElse<U>(defaultValueFn: (error: Err) => U): U;
    mapOk(fn: unknown): ErrorResult<Err, Common>;
    mapErr<E>(fn: (error: Err) => E): ErrorResult<E, Common>;
    map<T, E>(fns: {
        err: (error: Err) => E;
    }): T | E;
    and(fn: unknown): ErrorResult<Err, Common>;
    andPromise(fn: unknown): Promise<ErrorResult<Err, Common>>;
    toJSON(): ErrorResultData<Err, Common>;
    toResponse(): Response;
};
type OkResultMethods<Data, Common extends object> = {
    get isOk(): true;
    get isErr(): false;
    unwrap(): Data;
    or(defaultValue: unknown): Data;
    orElse(defaultValueFn: (error: unknown) => unknown): Data;
    mapOk<T>(fn: (data: Data) => T): OkResult<T, Common>;
    mapErr(fn: unknown): OkResult<Data, Common>;
    map<T, E>(fns: {
        ok: (data: Data) => T;
    }): T | E;
    and<T, E, C extends object>(fn: (data: Data) => Result<T, E, C>): Result<T, E, C>;
    andPromise<T, E, C extends object>(fn: (data: Data) => Promise<Result<T, E, C>>): Promise<Result<T, E, C>>;
    toJSON(): OkResultData<Data, Common>;
    toResponse(): Response;
};
declare function ResultFrom<Data, Err, Constant extends object = object>({ data, error, ...constant }: ResultData<Data, Err, Constant>): Result<Data, Err, Constant>;
export type IsOk<T> = T extends OkResult<any, any> ? true : false;
export type IsError<T> = T extends ErrorResult<any, any> ? true : false;
export type InferOkType<T> = T extends OkResult<infer Data, any> ? Data : never;
export type InferErrorType<T> = T extends ErrorResult<infer Err, any> ? Err : never;
export type InferResultData<T> = Extract<T, {
    status: "ok";
}> extends OkResult<infer Data> ? Data : never;
export type InferResultErr<T> = Extract<T, {
    status: "error";
}> extends ErrorResult<infer Err, any> ? Err : never;
type AllOkResults<Results> = Results extends [infer First, ...infer Rest] ? IsOk<First> extends true ? AllOkResults<Rest> extends never ? never : [InferOkType<First>, ...AllOkResults<Rest>] : never : [];
type FirstErrResult<Results> = Results extends [infer First, ...infer Rest] ? IsError<First> extends true ? InferErrorType<First> : FirstErrResult<Rest> : never;
type MapArrayToOk<T> = T extends [infer First, ...infer Rest] ? IsOk<First> extends true ? [InferOkType<First>, ...MapArrayToOk<Rest>] : [InferResultData<First>, ...MapArrayToOk<Rest>] : [];
type UnionOfErrors<T> = T extends [infer First, ...infer Rest] ? IsOk<First> extends true ? UnionOfErrors<Rest> : InferResultErr<First> | UnionOfErrors<Rest> : never;
declare function ResultAll<Results extends Result<any, any, any>[]>(...results: Results): Results extends [infer _First, ...infer _Rest] ? AllOkResults<Results> extends never ? FirstErrResult<Results> extends never ? Result<MapArrayToOk<Results>, UnionOfErrors<Results>> : ErrorResult<FirstErrResult<Results>> : OkResult<AllOkResults<Results>> : Results extends Array<infer T> ? Result<InferResultData<T>[], InferResultErr<T>> : never;
export declare function Ok<Data>(data: Data): OkResult<Data, object>;
export declare function Ok<Data, Common extends object>(data: Data, common: Common): OkResult<Data, Common>;
export declare function Err<Err>(error: Err): ErrorResult<Err, object>;
export declare function Err<Err, Common extends object>(error: Err, common: Common): ErrorResult<Err, Common>;
export declare const Result: {
    Ok: typeof Ok;
    Err: typeof Err;
    from: typeof ResultFrom;
    all: typeof ResultAll;
};
export default Result;
//# sourceMappingURL=result.d.ts.map