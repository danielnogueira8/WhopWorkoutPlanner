"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    runAndKill: function() {
        return runAndKill;
    },
    run: function() {
        return run;
    },
    runDevServer: function() {
        return runDevServer;
    },
    runProxy: function() {
        return runProxy;
    }
});
const _nodechild_process = require("node:child_process");
const _nodehttp = /*#__PURE__*/ _interop_require_default(require("node:http"));
const _nodenet = /*#__PURE__*/ _interop_require_default(require("node:net"));
const _httpproxy = /*#__PURE__*/ _interop_require_default(require("http-proxy"));
const _jose = require("jose");
_export_star(require("./parse-cli-options"), exports);
function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
            Object.defineProperty(to, k, {
                enumerable: true,
                get: function() {
                    return from[k];
                }
            });
        }
    });
    return from;
}
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const API_HOSTNAME = "api.whop.com";
const WS_HOSTNAME = "ws-prod.whop.com";
const WHOP_API_PREFIX = "/_whop/";
const APP_COMPONENTS = [
    "storage",
    "chat",
    "access",
    "auth",
    "feed",
    "oauth"
];
const API_ROUTING = [
    {
        match: `${WHOP_API_PREFIX}api/`,
        host: API_HOSTNAME,
        rewritePrefix: "/api"
    },
    {
        match: `${WHOP_API_PREFIX}public-graphql/`,
        host: API_HOSTNAME,
        rewritePrefix: "/public-graphql"
    },
    {
        match: `${WHOP_API_PREFIX}ws/`,
        host: WS_HOSTNAME,
        rewritePrefix: ""
    }
];
async function runAndKill(opts) {
    const { kill } = await run(opts);
    process.on("SIGINT", ()=>{
        kill();
    });
    process.on("exit", ()=>{
        kill();
    });
    process.on("beforeExit", ()=>{
        kill();
    });
}
async function run(opts) {
    const childProcess = opts.standalone ? undefined : await runDevServer(opts);
    const proxy = await runProxy({
        upstreamPort: childProcess?.port ?? opts.upstreamPort ?? 3000,
        proxyPort: opts.proxyPort,
        appComponentOriginOverrides: opts.appComponentOrigins,
        standalone: opts.standalone
    });
    if (childProcess) {
        childProcess.process.on("exit", ()=>{
            proxy.closeAllConnections();
            if (proxy.listening) proxy.close();
        });
    }
    proxy.on("close", ()=>{
        proxy.closeAllConnections();
        if (childProcess) {
            if (!childProcess.process.killed) childProcess.process.kill();
        }
    });
    function kill() {
        if (childProcess) {
            childProcess.process.kill();
        }
        proxy.closeAllConnections();
        proxy.close();
        process.exit(0);
    }
    return {
        process: childProcess?.process,
        proxy,
        kill
    };
}
async function runDevServer({ upstreamPort: port, npmCommand = "dev", command }) {
    const upstreamPort = port ?? await getUnusedPort();
    const p = (0, _nodechild_process.spawn)(command ?? `npm run ${npmCommand}`, {
        env: {
            ...process.env,
            PORT: upstreamPort.toFixed(0)
        },
        shell: true
    });
    p.stdout.on("data", (chunk)=>{
        process.stdout.write(chunk);
    });
    p.stderr.on("data", (chunk)=>{
        process.stderr.write(chunk);
    });
    return {
        process: p,
        port: upstreamPort
    };
}
async function runProxy({ upstreamPort, proxyPort: proxyPortParam, appComponentOriginOverrides, standalone }) {
    const proxyPort = proxyPortParam || Number.parseInt(process.env.PORT || "3000");
    // biome-ignore lint/suspicious/noConsoleLog: allow
    console.log("\n --------------------------------------------------");
    // biome-ignore lint/suspicious/noConsoleLog: allow
    console.log(` ⋅ ✔︎ Running ${standalone ? "the proxy" : "your app"} on: http://localhost:${proxyPort}`);
    // biome-ignore lint/suspicious/noConsoleLog: allow
    console.log(" --------------------------------------------------\n");
    if (standalone) {
        // biome-ignore lint/suspicious/noConsoleLog: allow
        console.log(` ⋅ Running in standalone mode, open another terminal and run your app on port ${upstreamPort} \n`);
    } else {
        // biome-ignore lint/suspicious/noConsoleLog: allow
        console.log(` ⋅ to bypass the proxy, use the following original port: ${upstreamPort}`);
        // biome-ignore lint/suspicious/noConsoleLog: allow
        console.log(" ⋅ logs from your app will now appear here ↓\n");
    }
    const proxy = _httpproxy.default.createProxyServer({
        target: `http://localhost:${upstreamPort}`,
        ws: true
    });
    function modResponse(proxyRes, _req, _res) {
        // Delete incase some frameworks set it. Allows upstream to be displayed in iframe.
        proxyRes.headers["x-frame-options"] = undefined;
    }
    function setCookies(proxyReq, req) {
        const cookieString = (req.headers.cookie || "").replace(/;\s*$/, "");
        const newCookie = [
            cookieString
        ];
        for (const [sessionId, checkoutSessionToken] of CHECKOUT_SESSION_IDS){
            const cookie = `whop_checkout_session_token-${sessionId}=${checkoutSessionToken}`;
            newCookie.push(cookie);
        }
        if (USER_TOKEN) {
            newCookie.push(`whop_user_token=${USER_TOKEN};`);
            proxyReq.setHeader("x-whop-user-token", USER_TOKEN);
        } else {
            newCookie.push("");
        }
        proxyReq.setHeader("cookie", newCookie.join("; "));
        if (APP_ID) {
            proxyReq.setHeader("x-whop-app-id", APP_ID);
        }
    }
    const appComponentProxies = APP_COMPONENTS.map((component)=>{
        const appComponentOriginOverride = appComponentOriginOverrides?.[component];
        const p = _httpproxy.default.createProxyServer({
            target: appComponentOriginOverride ?? `https://${component}.${API_HOSTNAME}`,
            changeOrigin: true,
            ws: true
        });
        p.on("proxyReq", (proxyReq, req, _res, _options)=>{
            setCookies(proxyReq, req);
        });
        p.on("proxyRes", modResponse);
        return [
            component,
            p
        ];
    }).reduce((acc, [component, proxy])=>{
        acc[component] = proxy;
        return acc;
    }, {});
    const mainApiProxy = _httpproxy.default.createProxyServer({
        target: `https://${API_HOSTNAME}`,
        changeOrigin: true,
        ws: true
    });
    const websocketProxy = _httpproxy.default.createProxyServer({
        target: `https://${WS_HOSTNAME}`,
        changeOrigin: true,
        ws: true
    });
    mainApiProxy.on("proxyReq", (proxyReq, req, _res, _options)=>{
        setCookies(proxyReq, req);
    });
    mainApiProxy.on("proxyRes", modResponse);
    proxy.on("proxyReq", (proxyReq, req, _res, _options)=>{
        setCookies(proxyReq, req);
    });
    proxy.on("proxyRes", modResponse);
    proxy.on("error", (err, req, res)=>{
        console.error(req, res, err);
    });
    const proxyServer = _nodehttp.default.createServer(async (req, res)=>{
        // Parse information from the request.
        const requestURL = new URL(req.url || "", `http://${req.headers.host || "http://localhost"}`);
        const token = requestURL.searchParams.get("whop-dev-user-token");
        if (token) {
            await setToken(token);
        }
        const checkoutSessionToken = requestURL.searchParams.get("whop_checkout_session_token");
        if (checkoutSessionToken) {
            ingestCheckoutSessionToken(checkoutSessionToken);
        }
        // if (!USER_TOKEN) {
        // 	res.writeHead(403);
        // 	res.end(
        // 		"There is no user token set. Please make sure you are viewing the app through the whop.com iframe.",
        // 	);
        // 	return;
        // }
        // TODO: decide where to proxy to based on the request.
        if (requestURL.pathname.startsWith(WHOP_API_PREFIX)) {
            if (USER_TOKEN) {
                const authorizationHeader = `Bearer ${USER_TOKEN}`;
                req.headers.authorization = authorizationHeader;
            }
            // Detect if we are requesting an app component
            for (const app of APP_COMPONENTS){
                const prefix = `${WHOP_API_PREFIX}${app}/`;
                if (requestURL.pathname.startsWith(prefix)) {
                    requestURL.pathname = requestURL.pathname.slice(prefix.length - 1);
                    requestURL.host = `${app}.${API_HOSTNAME}`;
                    requestURL.port = "443";
                    requestURL.protocol = "https";
                    // console.log(
                    //   '[APP_COMPONENT] forwarded request to: ' + requestURL.toString(),
                    // );
                    req.url = requestURL.pathname + requestURL.search;
                    return appComponentProxies[app].web(req, res);
                }
            }
            // If we are not requesting an app component, then we are requesting the api
            for (const apiRoute of API_ROUTING){
                if (requestURL.pathname.startsWith(apiRoute.match)) {
                    requestURL.host = apiRoute.host;
                    requestURL.port = "443";
                    requestURL.pathname = `${apiRoute.rewritePrefix}${requestURL.pathname.slice(apiRoute.match.length - 1)}`;
                    requestURL.protocol = "https";
                    req.url = requestURL.pathname + requestURL.search;
                    const proxyToUse = requestURL.pathname.startsWith("/_whop/ws/") ? websocketProxy : mainApiProxy;
                    return proxyToUse.web(req, res);
                }
            }
            if (requestURL.pathname === "/_whop/analytics/analytics-v1.js") {
                res.writeHead(200, {
                    "Content-Type": "application/javascript"
                });
                res.end('console.log("WHOP ANALYTICS DISABLED DURING DEV MODE");');
            } else {
                res.writeHead(404);
                res.end("Not found");
                return;
            }
        } else {
            proxy.web(req, res);
        }
    });
    proxyServer.on("upgrade", (req, socket, head)=>{
        const requestURL = new URL(req.url || "", `http://${req.headers.host || "http://localhost"}`);
        if (requestURL.pathname.startsWith(WHOP_API_PREFIX)) {
            if (USER_TOKEN) {
                const authorizationHeader = `Bearer ${USER_TOKEN}`;
                req.headers.authorization = authorizationHeader;
                req.headers["x-whop-user-token"] = USER_TOKEN;
            }
            for (const apiRoute of API_ROUTING){
                if (requestURL.pathname.startsWith(apiRoute.match)) {
                    requestURL.host = apiRoute.host;
                    requestURL.port = "443";
                    requestURL.pathname = `${apiRoute.rewritePrefix}${requestURL.pathname.slice(apiRoute.match.length - 1)}`;
                    requestURL.protocol = "wss";
                    req.url = requestURL.pathname + requestURL.search;
                    const proxyToUse = apiRoute.match === "/_whop/ws/" ? websocketProxy : mainApiProxy;
                    return proxyToUse.ws(req, socket, head);
                }
            }
        }
        proxy.ws(req, socket, head);
    });
    return new Promise((res)=>{
        proxyServer.listen(proxyPort, undefined, undefined, ()=>{
            res(proxyServer);
        });
    });
}
async function getUnusedPort() {
    const server = _nodenet.default.createServer();
    return new Promise((resolve, reject)=>{
        server.listen(0, ()=>{
            const address = server.address();
            resolve(address.port);
            server.close((err)=>{
                if (err) reject(err);
            });
        });
    });
}
let USER_TOKEN = null;
const CHECKOUT_SESSION_IDS = new Map();
let APP_ID = process.env.WHOP_APP_ID ?? null;
let USER_ID = null;
function setToken(token) {
    USER_TOKEN = token;
    if (USER_TOKEN !== null) {
        try {
            const body = (0, _jose.decodeJwt)(USER_TOKEN);
            APP_ID = typeof body.aud === "string" ? body.aud : null;
            const userId = typeof body.sub === "string" ? body.sub : null;
            if (userId) {
                if (USER_ID !== userId) {
                    USER_ID = userId;
                    // biome-ignore lint/suspicious/noConsoleLog: allow
                    console.log(` ⋅ ✔︎ Set user ID to: ${userId}`);
                }
            }
        } catch  {
        //empty
        }
    }
// const filepath = path.join(tmpdir(), 'com.whop.apps', 'whop_user_token.txt');
// if (token === null) {
//   await unlink(filepath).catch(() => null);
//   return;
// }
// await writeFile(filepath, token, 'utf-8').catch(() => null);
}
// function renderFile(
//   file: string,
//   data: Record<string, string | number | boolean>,
// ) {
//   let output = file;
//   for (const [key, value] of Object.entries(data)) {
//     output = output.replace(`{${key}}`, value.toString());
//   }
//   return output;
// }
function ingestCheckoutSessionToken(token) {
    const decoded = (0, _jose.decodeJwt)(token);
    if (typeof decoded.sess_id !== "string") return;
    CHECKOUT_SESSION_IDS.set(decoded.sess_id, token);
}
